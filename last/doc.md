# main.py 코드 상세 분석 문서

이 문서는 `main.py` 스크립트의 전체적인 구조, 각 함수의 기능, 사용되는 변수, 그리고 실행 로직에 대해 매우 상세하게 설명합니다.

## 1. 개요

`main.py`는 Google의 Generative AI 모델(Gemini)을 사용하여 사용자가 정의한 '성향'에 따라 다수의 가상 페르소나를 생성하는 스크립트입니다. 생성된 페르소나들은 독립적인 대화 기록(메모리)을 가지며, 사용자가 입력한 질문에 대해 각자의 개성에 따라 응답합니다. 스크립트는 여러 API 키를 활용한 병렬 처리를 통해 다수의 페르소나를 효율적으로 생성하고, 이들에게 동시에 질문을 던져 응답을 수집합니다. 수집된 응답은 상세한 Markdown 보고서와 응답 분포를 시각화한 막대그래프 이미지로 자동 저장되어, 특정 질문에 대한 페르소나 그룹의 반응을 쉽게 분석할 수 있도록 돕습니다.

## 2. 초기 설정 및 전역 변수

스크립트 실행에 앞서 필요한 환경을 설정하고 전역 변수를 정의합니다.

### 2.1. 라이브러리 임포트

- `os`: 파일 경로 생성, 디렉터리 존재 여부 확인 등 운영체제와 상호작용하는 기능을 위해 사용됩니다.
- `dotenv.load_dotenv`: `.env` 파일에 저장된 환경 변수(API 키 등)를 스크립트 내에서 사용할 수 있도록 로드합니다.
- `json`: 페르소나 데이터(`PERSONAS.json`)와 각 페르소나의 대화 기록을 파일로 저장하고 읽기 위해 사용됩니다.
- `sys`: 스크립트 실행을 중단(`sys.exit()`)하기 위해 사용됩니다.
- `concurrent.futures`: 여러 API 요청을 동시에 처리(병렬 처리)하여 전체 작업 시간을 단축하기 위해 `ThreadPoolExecutor`를 사용합니다.
- `time`: API 요청이 실패했을 때(주로 할당량 초과 시) 일정 시간 대기(`time.sleep()`)하기 위해 사용됩니다.
- `google.generativeai as genai`: Gemini AI 모델을 사용하기 위한 Google의 공식 라이브러리입니다.
- `google.api_core.exceptions.ResourceExhausted`: API 사용량 한도를 초과했을 때 발생하는 예외를 처리하기 위해 사용됩니다.
- `matplotlib.pyplot as plt`: 수집된 응답의 분포를 막대그래프로 시각화하고 이미지 파일로 저장하기 위해 사용됩니다.
- `re`: 질문 텍스트를 파일 시스템에서 사용 가능한 폴더 이름으로 변환하기 위해 정규 표현식을 사용합니다.
- `from collections import Counter`: 페르소나들의 숫자 응답(1~5) 빈도를 쉽게 계산하기 위해 사용됩니다.

### 2.2. 전역 변수

- **`API_KEYS` (list)**:
    - `.env` 파일에서 `API_1`, `API_2`, ... 형식으로 정의된 모든 Google AI API 키를 저장하는 리스트입니다.
    - 스크립트는 `i=1`부터 시작하는 `while True` 루프를 통해 `os.getenv(f'API_{i}')`를 호출하여 키를 순차적으로 불러옵니다. 키가 더 이상 존재하지 않으면(`None`) 루프가 중단됩니다.

- **`CREATION_SYSTEM` (str)**:
    - 페르소나 '생성'을 위한 시스템 프롬프트입니다. 이 프롬프트는 AI에게 다음과 같은 역할을 부여하고 출력 형식을 엄격하게 지정합니다.
    - **역할**: 페르소나 생성 전용 AI.
    - **지시**: 사용자의 '성향' 입력을 바탕으로 4개의 특정 키(`name`, `mind`, `action`, `character`)만을 가진 순수 JSON 배열을 출력하도록 지시합니다. 추가 설명이나 주석은 금지됩니다. 이름은 영어로, 띄어쓰기 없이 생성하도록 요구합니다. 각 키에 대한 설명은 매우 구체적이고 길게 작성하도록 유도합니다.

- **`VARIOUS_SYSTEM` (str)**:
    - 페르소나의 '다양성'을 확보하기 위한 시스템 프롬프트입니다.
    - **역할**: 페르소나 다양성 생성 AI.
    - **지시**: 기존에 생성된 페르소나 정보와 기본 '성향'을 입력받아, 이들과 겹치지 않는 새로운 특성을 반영한 '교정된 성향'을 생성하도록 지시합니다. 이는 매번 새로운 페르소나를 생성할 때마다 약간의 변주를 주기 위함입니다.

## 3. 핵심 함수

### 3.1. 파일 입출력 함수

- **`load_json(path)`**:
    - **역할**: JSON 파일을 안전하게 읽어 파이썬 객체로 변환합니다.
    - **매개변수**:
        - `path` (str): 읽어올 JSON 파일의 절대 또는 상대 경로.
    - **로직**: `os.path.exists(path)`로 파일 존재 여부를 먼저 확인합니다. 파일이 있으면 `utf-8` 인코딩으로 파일을 열어 `json.load()`로 내용을 읽어 반환합니다. 파일이 없으면 `FileNotFoundError`를 방지하기 위해 빈 리스트(`[]`)를 반환합니다.

- **`save_json(path, data)`**:
    - **역할**: 파이썬 객체(`data`)를 JSON 파일로 저장합니다.
    - **매개변수**:
        - `path` (str): 저장할 파일의 경로.
        - `data` (list 또는 dict): 파일에 저장할 데이터.
    - **로직**:
        1. `os.path.dirname(path)`로 파일이 저장될 디렉터리 경로를 추출합니다.
        2. `os.makedirs(dir_, exist_ok=True)`를 통해 해당 디렉터리가 존재하지 않으면 생성합니다.
        3. `utf-8` 인코딩으로 파일을 열고 `json.dump()`를 사용하여 데이터를 저장합니다.
        4. `ensure_ascii=False`: 한글이 유니코드(`\uXXXX`) 형태로 변환되지 않고 원본 그대로 저장되도록 합니다.
        5. `indent=4`: JSON 파일의 가독성을 높이기 위해 4칸 들여쓰기를 적용합니다.

- **`save_memory(entry, memory_file)`**:
    - **역할**: 특정 페르소나의 대화 기록을 JSON 파일에 추가합니다.
    - **매개변수**:
        - `entry` (dict): 새로 추가할 대화 항목. `{'role': 'user', 'content': '...'}` 또는 `{'role': 'assistant', 'content': '...'}` 형식입니다.
        - `memory_file` (str): 해당 페르소나의 대화 기록이 저장된 파일 경로.
    - **로직**: `load_json`으로 기존 대화 기록(`mem`)을 불러온 뒤, 리스트의 끝에 새로운 `entry`를 `append`하고, `save_json`을 호출하여 파일 전체를 덮어씁니다.

### 3.2. AI 호출 및 상호작용 함수

- **`history_str(buf)`**:
    - **역할**: 대화 기록 리스트를 AI 모델에 입력하기 적합한 단일 문자열로 변환합니다.
    - **매개변수**:
        - `buf` (list): `{'role': ..., 'content': ...}` 딕셔너리들의 리스트.
    - **반환값**: 각 딕셔너리를 "role: content\n" 형식의 문자열로 변환하여 모두 이어붙인 텍스트를 반환합니다.

- **`AI(prompt, system, memory_file=None, api_key=None, retries=3)`**:
    - **역할**: Gemini AI 모델에 요청을 보내고 응답을 받는 핵심 인터페이스 함수입니다.
    - **매개변수**:
        - `prompt` (str): AI에게 전달할 현재 사용자의 질문이나 명령어.
        - `system` (str): AI의 역할과 행동 지침을 정의하는 시스템 프롬프트.
        - `memory_file` (str, optional): 대화의 맥락을 유지하기 위해 이전 대화 기록을 불러오고 저장할 파일의 경로. `None`이면 대화 기록을 사용하지 않습니다.
        - `api_key` (str, optional): 요청에 사용할 특정 API 키.
        - `retries` (int): `ResourceExhausted` 오류 발생 시 재시도할 최대 횟수 (기본값 3).
    - **로직**:
        1. **API 설정**: `genai.configure(api_key=api_key)`로 현재 요청에 사용할 API 키를 설정합니다.
        2. **모델 초기화**: `genai.GenerativeModel('gemini-1.5-flash', system_instruction=system)`을 통해 시스템 프롬프트를 적용한 모델 객체를 생성합니다.
        3. **대화 기록 결합**: `memory_file`이 제공되면, `load_json`으로 기록을 불러와 `history_str`로 문자열화한 뒤, 현재 `prompt`와 합쳐(`combined`) 모델에 전달할 최종 입력 텍스트를 만듭니다.
        4. **사용자 입력 저장**: `memory_file`이 있다면, 현재 `prompt`를 사용자 대화로 간주하여 `save_memory`를 통해 파일에 기록합니다.
        5. **재시도 루프**: `while True` 루프 안에서 API 요청을 시도합니다.
            - **성공 시**: `model.start_chat().send_message(combined)`로 요청을 보내고 응답(`resp`)을 받습니다. 응답 텍스트(`text`)에서 불필요한 "assistant: " 접두사를 제거한 뒤 `reply` 변수에 저장합니다. 이 `reply`를 `save_memory`를 통해 파일에 기록하고, 함수 결과로 반환합니다.
            - **실패 시 (`ResourceExhausted`)**: API 할당량 초과 예외가 발생하면, `attempt` 카운터를 1 증가시킵니다.
                - `attempt`가 `retries`를 초과하면 경고 메시지를 출력하고 빈 문자열(`''`)을 반환하여 더 이상 시도하지 않습니다.
                - 재시도 횟수 내라면, `wait = 2 ** attempt` 공식을 통해 대기 시간(2, 4, 8초...)을 계산하고 `time.sleep(wait)`로 대기한 후 루프의 처음으로 돌아가 재시도합니다.

### 3.3. 페르소나 생성 함수

- **`generate_personas(count, api_count, trait)`**:
    - **역할**: `count` 수만큼의 페르소나를 `api_count`개의 API 키를 사용하여 병렬로 생성합니다.
    - **매개변수**:
        - `count` (int): 생성할 페르소나의 총 수.
        - `api_count` (int): 동시에 사용할 API 키의 수.
        - `trait` (str): 생성될 페르소나들이 공통적으로 가질 기본 '성향'.
    - **로직**:
        1. **작업 분배**: `divmod(count, api_count)`를 통해 각 API 키가 생성할 페르소나 수(`rounds`)와 나머지(`rem`)를 계산합니다.
        2. **다양성 확보**: `PERSONAS.json`에서 기존 페르소나 정보를 읽어 `VARIOUS_SYSTEM` 프롬프트와 결합하여, AI에게 기존과 다른 '교정된 성향'(`various`)을 생성하도록 요청합니다.
        3. **병렬 생성**: `concurrent.futures.ThreadPoolExecutor`를 사용하여 `api_count`개의 스레드를 생성합니다. 각 스레드는 `call_api` 내부 함수를 실행합니다.
        4. **`call_api(api_key)` 내부 함수**:
            - `trait`와 `various`를 조합하여 최종 프롬프트를 구성합니다.
            - `CREATION_SYSTEM`을 적용하여 `AI` 함수를 호출하고 페르소나 정보가 담긴 JSON 문자열을 받습니다.
            - `json.loads(resp)`로 응답을 파싱합니다. 만약 AI 응답이 순수 JSON이 아닌 다른 텍스트를 포함할 경우, `resp.find('{')`와 `resp.rfind('}')`를 사용해 JSON 부분만 추출하여 파싱을 재시도하는 예외 처리를 포함합니다.
            - 성공적으로 파싱된 페르소나 객체를 반환합니다.
        5. 모든 스레드의 실행이 완료되면, 생성된 페르소나 객체들을 `generated` 리스트에 취합하여 반환합니다.

### 3.4. 질문 및 결과 처리 함수

- **`process_group(group, key)`**:
    - **역할**: 스레드 풀의 개별 스레드가 실행하는 작업 단위. 페르소나 그룹에게 질문을 던지고 응답을 수집합니다.
    - **매개변수**:
        - `group` (list): 질문을 받을 페르소나 객체들의 리스트 (청크).
        - `key` (str): 이 그룹을 처리하는 데 사용할 API 키.
    - **로직**: `group` 내의 각 페르소나 `p`에 대해 `AI(question, p['system'], p['file'], key)`를 호출합니다. 각 페르소나는 자신만의 시스템 프롬프트(`p['system']`)와 대화 기록 파일(`p['file']`)을 사용합니다. 최종적으로 `(페르소나 이름, 응답 내용)` 튜플로 구성된 리스트(`out`)를 반환합니다.

- **`save_results(question, results)`**:
    - **역할**: 수집된 모든 응답을 종합하여 보고서 파일과 그래프 이미지로 저장합니다.
    - **매개변수**:
        - `question` (str): 페르소나에게 던졌던 원본 질문.
        - `results` (list): 모든 페르소나로부터 수집된 `(이름, 응답)` 튜플의 전체 리스트.
    - **로직**:
        1. **폴더명 생성**: `re.sub`를 사용하여 질문 텍스트에서 파일 시스템에 부적합한 문자(특수문자 등)를 제거하고, 공백을 밑줄(`_`)로 바꿔 유효한 폴더 이름을 만듭니다.
        2. **폴더 및 파일 생성**: `os.makedirs(folder, exist_ok=True)`로 폴더를 생성하고, 그 안에 `{folder}.md` 파일을 엽니다.
        3. **Markdown 보고서 작성**:
            - 파일 최상단에 질문을 제목(`<h1>`)으로 기록합니다.
            - 총 응답 페르소나 수를 기록합니다.
            - `results` 리스트를 순회하며 각 페르소나의 응답을 파싱합니다. 응답은 보통 첫 줄에 숫자(1~5), 다음 줄에 이유가 오는 형식입니다. 이를 분리하여 `이름 : 숫자\n    : 이유\n\n---\n\n` 형식으로 파일에 기록합니다.
        4. **그래프 생성**:
            - `Counter`를 사용하여 모든 숫자 응답의 빈도를 계산합니다.
            - `matplotlib.pyplot`을 사용하여 `[1, 2, 3, 4, 5]` 각 항목의 빈도를 나타내는 막대그래프를 생성합니다.
            - `plt.savefig()`를 호출하여 생성된 그래프를 `{folder}_그래프.png` 이미지 파일로 저장합니다.

## 4. 메인 실행 로직 (`if __name__ == '__main__':`)

스크립트가 직접 실행될 때의 주된 흐름입니다.

1.  **페르소나 준비**:
    - `load_json('PERSONAS.json')`으로 기존 페르소나를 불러옵니다.
    - `auto = input(...)`을 통해 사용자에게 페르소나를 자동 생성할지, 수동으로 입력할지 선택받습니다.
    - **자동 생성 (`y`)**:
        - `count`(생성 수), `api_cnt`(사용할 API 수), `trait`(성향)을 입력받습니다.
        - `generate_personas()`를 호출하여 `raw` 페르소나 데이터를 받습니다.
        - `raw` 데이터를 순회하며 각 페르소나(`p`)에 대한 후처리 작업을 수행합니다:
            - `base = p['name']`: 기본 이름을 추출합니다.
            - `name_counts`: 동일한 기본 이름을 가진 페르소나가 여러 개 생성될 경우 `_001`, `_002` 와 같이 번호를 붙여주기 위해 카운팅합니다.
            - `p['name'] = idx`: 최종 고유 이름을 할당합니다.
            - `p['file']`: 대화 기록 파일 경로를 `./memory/{idx}_MEM.json` 형식으로 설정합니다.
            - `p['system']`: 각 페르소나의 `mind`, `action`, `character` 정보를 조합하여 개별 시스템 프롬프트를 생성합니다.
        - 후처리된 페르소나들을 전체 `personas` 리스트에 추가하고 `save_json`으로 파일에 저장합니다.
    - **수동 입력 (`n`)**:
        - 입력할 페르소나 수(`n`)를 받고, 수만큼 반복하며 `name`, `mind`, `action`, `character`를 직접 입력받아 페르소나 객체를 구성하고 저장합니다.

2.  **질문 세션**:
    - `if not personas`: 생성되거나 로드된 페르소나가 없으면 스크립트를 종료합니다.
    - **작업 분배**: `api_cnt`(사용할 API 키 수)에 맞춰 전체 `personas` 리스트를 여러 개의 작은 그룹(`chunks`)으로 나눕니다. 이는 병렬 처리를 위함입니다.
    - `question_many = input(...)`으로 여러 질문을 한 번에 할지, 대화형으로 하나씩 할지 선택받습니다.
    - **여러 질문 (`y`)**:
        - 질문 수(`questions_n`)와 각 질문 내용을 입력받아 `questions` 리스트에 저장합니다.
        - `questions` 리스트를 순회하며 각 질문(`q`)에 대해 다음을 반복합니다:
            - `ThreadPoolExecutor`를 사용하여 `api_cnt`개의 스레드로 `process_group` 함수를 병렬 실행합니다. 각 스레드는 페르소나 청크(`grp`)와 API 키(`k`)를 받아 해당 그룹의 응답을 처리합니다.
            - 모든 스레드가 완료되면 `results` 리스트에 모든 응답이 취합됩니다.
            - `save_results(q, results)`를 호출하여 해당 질문에 대한 결과를 저장합니다.
        - 모든 질문 처리가 끝나면 시스템을 종료합니다.
    - **단일 질문 (`n`)**:
        - `while True` 루프에 진입하여 사용자가 `exit`를 입력할 때까지 계속 질문을 받습니다.
        - `q = input('> ')`로 질문을 입력받습니다.
        - 여러 질문 모드와 동일한 병렬 처리 로직을 사용하여 응답을 수집하고, `save_results`로 결과를 저장합니다. 루프는 다음 질문을 받기 위해 계속됩니다.
